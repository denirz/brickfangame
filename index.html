<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="manifest" href="site.webmanifest">
  <link rel="apple-touch-icon" href="icon.png">
  <!-- Place favicon.ico in the root directory -->

  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/main.css">
  <script>
    function sleep(milliseconds) {
  var start = new Date().getTime();
  for (var i = 0; i < 1e7; i++) {
    if ((new Date().getTime() - start) > milliseconds){
      break;
    }
  }
}
  </script>

  <script>
    let nlines = 40;

    class Qlist{
            constructor(){
                this.items = new Array();
                this.color = "rgba(0,0 ,255, 1)"
            }
          addQuadrant(Item,fix=1){
                var b=Object.assign({},Item);
                b.perimeter = Item.perimeter;
                b.checkpoint_in = Item.checkpoint_in;
                var nerrors = 0;
                var nsiebling = 0
                this.items.forEach(function (e) {
                    var res =Item.checkother(e.x,e.y,e.n,e.m);
                    if(res == '-1'){nerrors++}
                    if(res == '1'){nsiebling++}
                });
                // console.log(" Number of errors ",nerrors);
                // console.log(" Number of siebling ",nsiebling);
                if (fix ===2 && nerrors===0){
                    return 1
                }
                if (nerrors===0 && nsiebling >= 1 )
                  {
                  if (fix===1){this.items.push(b);}
                      return 1
                  }
                if (this.items.length === 0)
                    {
                  if (fix===1){this.items.push(b)}
                        return 1
                  }
                return 0
          }
          drawQlist(canvas){
                let color =this.color;
              var ctx = canvas.getContext("2d");
              var s = getCellsize();
              this.items.forEach(function (e) {

                  ctx.save()
                  ctx.fillStyle=color;
                  ctx.fillRect(e.x*s[0],e.y*s[1],e.n*s[0],e.m*s[1]);
                  ctx.strokeStyle="rgba(0,0 ,127, 1)";
                  ctx.strokeRect(e.x*s[0],e.y*s[1],e.n*s[0],e.m*s[1]);
                  ctx.restore();
              })

          }
          proposeNewPlace(n,m){
              var fullp  =  new Array()
              // console.log("Number of items i narray",this.items.length);
              for (var item of this.items){
                  fullp = fullp.concat(item.perimeter())
              }
              console.log(fullp)
              for (var p of fullp){
                  console.log(p)
                  drawpixel(p[0],p[1])
                  sleep(1000);////
                  clearpixel(p[0],p[1])
                  // drawpixel(p[0],p[1]);
                  let candidat =[p[0]-n+1,p[1]-m+1]
                  let tq = new Quadrant(candidat[0],candidat[1],n,m)

                  let result = this.addQuadrant(tq,fix=0);
                  if (result === 1){
                      tq.testdraw();
                  console.log("Quadrantresul",result,candidat);
                  drawpixel(candidat[0],candidat[1]);
                  sleep(1000);
                  clearpixel(candidat[0],candidat[1]);
                      return  candidat

                  }

                  }
          }
    }


    class Quadrant{
        constructor(x,y){
            this.x=x;
            this.y=y;
            this.n=this.randsize()[0];
            this.m=this.randsize()[1];
        }
        setcoords(canvas,x,y){

            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
            ctx.fillStyle="rgba(255,0 , 0, 0.5)";
            this.x=x;
            this.y=y;
            drawgrid(canvas);
            ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);

        }
        randsize(){
            var n= parseInt(Math.random()*6)+1;
            var m= parseInt(Math.random()*6)+1;
            return [n,m]
        }
        output(){
            console.log(this.x,this.n)
            console.log(this.y,this.m)
        }
        fix(canvas,listitems){
            var res = listitems.addQuadrant(this);
            // console.log(res);
            if (res ===1){
              this.reload(canvas)
                }
        }
        reload(canvas){
            this.clear(canvas)
            this.n=this.randsize()[0];
            this.m=this.randsize()[1];
            this.draw(canvas);
            drawgrid(canvas)
        }
        rotate(canvas){
            this.clear(canvas);
            let temp=this.n;
            this.n=this.m;
            this.m=temp;
            this.draw(canvas);
            drawgrid(canvas);
        }
        checkother(x,y,n,m){
            // console.log("CHECKOTHER")
            // просто проверка на пересечения:
            for(var x_t=this.x;x_t<this.x+this.n;x_t++){
                for(var y_t=this.y;y_t<this.y+this.m;y_t++){
                    if( x_t>x-1 && x_t<x+n && y_t>y-1 && y_t<y+m){
                        // console.log("ERROR X",x_t,x,x+n);
                        // console.log("ERROR Y",y_t,y,y+m);
                        return '-1';
                    }
                }
            }
            //  проверка на соседство
            var sieb =0
            if (this.x===x+n && (this.y>=y && this.y< y+m)){sieb++}
            if (this.x===x+n && (this.y+this.m >y && this.y+this.m < y+m)){sieb++}
            if (this.x===x+n && (this.y+this.m < y && this.y+this.m > y+m)){sieb++}

            if (this.x+this.n===x && (this.y>=y && this.y< y+m)) {sieb++}
            if (this.x+this.n===x && (this.y+this.m >y && this.y+this.m < y+m)) {sieb++}
            if (this.x+this.n===x && (this.y+this.m <y && this.y+this.m > y+m)) {sieb++}

            if (this.y === y+m && (this.x>=x && this.x < x+n)){sieb++}
            if (this.y === y+m && (this.x<x && this.x+this.n > x)){sieb++}
            if (this.y+this.m === y && (this.x>=x && this.x <x+n)){sieb++}
            // if (this.y+this.m === y && (this.x<x && this.x+this.n <x+n)){sieb++}
            if (this.y+this.m === y && (this.x<x && this.x+this.n >x)){sieb++}
            // console.log("Sieb",sieb);
            if (sieb >=1)
            {
                // console.log("GOOD PLACE");
                return 1;
            }
            return 0;
        }
        clear(canvas){
            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1])
        }
        draw(canvas){
                  var ctx = canvas.getContext("2d");
                  ctx.fillStyle="rgba(255,0 , 0, 0.5)";
                  // ctx.fillStyle="FFFF00";
                  var s = getCellsize();
                  // console.log("sizes",s)
                  ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
        }
        testdraw(){
                  let canvas = document.getElementById("main");
                  var ctx = canvas.getContext("2d");
                  ctx.save()
                  ctx.fillStyle="rgba(255,255 , 0, 0.8)";
                  // ctx.fillStyle="FFFF00";
                  var s = getCellsize();
                  // console.log("sizes",s)
                  ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
                  ctx.restore()
        }
        moveright(canvas){
            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
            ctx.fillStyle="rgba(255,0 , 0, 0.5)";
            this.x=this.x+1;
            drawgrid(canvas);
            ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
        }
        moveleft(canvas){
            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
            ctx.fillStyle="rgba(255,0 , 0, 0.5)";
            this.x=this.x-1;
            drawgrid(canvas);
            ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
        }
        moveup(canvas){
            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
            ctx.fillStyle="rgba(255,0 , 0, 0.5)";
            this.y=this.y-1;
            drawgrid(canvas);
            ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
        }
        movedown(canvas){
            var ctx = canvas.getContext("2d");
            var s = getCellsize();
            ctx.clearRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
            ctx.fillStyle="rgba(255,0 , 0, 0.5)";
            this.y=this.y+1;
            drawgrid(canvas);
            ctx.fillRect(this.x*s[0],this.y*s[1],this.n*s[0],this.m*s[1]);
        }
        perimeter(){
            var p =  new Array();
            for(var x_t=this.x; x_t<this.x+this.n; x_t++){
                p.push([x_t,this.y-1]);
                p.push([x_t,this.y+this.m]);
            }
            for( var y_t=this.y;y_t<this.y+this.m;y_t++){
                p.push([this.x-1,y_t]);
                p.push([this.x+this.n,y_t])
            }
            return p
        }
        checkcorrectness(set){
            ///not ready yet !
            if (! set instanceof Qlist){return 'Error'}
            let sumres = 0;
            for (var item of set.items){
                // console.log("X",item.x,item.n,"Y",item.y,item.m)
                let res = this.checkother(item.x,item.y,item.n,item.m)
                // console.log("Res = ",res)
                if (res === '-1'){
                    return "Cross"
                }
                sumres = sumres + res
            }
            return sumres

        }
        perimeter_draw(canvas){
            var p=this.perimeter();

            var ctx = canvas.getContext("2d");
            ctx.save()
            ctx.fillStyle="rgba(255,255,0,0.5)";
            var s = getCellsize();
            for (var cell of p){
                  ctx.fillRect(cell[0]*s[0],cell[1]*s[1],s[0],s[1]);
            }
            ctx.restore()

        }
        checkpoint_in(x,y){
            if (x>=this.x && x < this.x + this.n && y >=this.y && y <this.y+this.m) {
              return 1
              }
            return 0
            }
        steprand(canvas,candidat){
            this.clear(canvas);
            this.x=candidat[0];
            this.y=candidat[1];
            this.draw(canvas)
            drawgrid(canvas)
        }


    }
    let a  = new Quadrant(1,1);
    let listitems = new Qlist();
    let listmashineitems = new Qlist();
    listmashineitems.color = "rgba(0,255 ,0, 1)"
    var b = new Quadrant(nlines-8,nlines-8)

    function mashinegame(canvas){
        // b.perimeter_draw(canvas)
        console.log("LENTH",listmashineitems.items.length)
        if (listmashineitems.items.length ===0){
          var allowed_u = listitems.addQuadrant(b,fix=0);
          var allowed_m = listmashineitems.addQuadrant(b);
          listmashineitems.drawQlist(canvas);
          b.reload(canvas);
            return 0;
        }
        // console.log("Quad1:",b,"correctness:",b.checkcorrectness(listmashineitems));
        // if (b.checkcorrectness(listmashineitems) == 'Cross' ){
        //     b.setcoords(canvas,1,1);
        //     console.log("SET")
        // }
        // if (b.checkcorrectness(listmashineitems) == 0 ){
        //     b.setcoords(canvas,1,5);
        //     console.log("SET")
        // }
        for(i=0;i<nlines;i++){
            for(j=0;j<nlines;j++){
                b.setcoords(canvas,j,i); //todo может быть добавить немнго ума в  такой перебор
                // console.log("Quad1:",b,"correctness:",b.checkcorrectness(listmashineitems));
                if((b.checkcorrectness(listmashineitems) > 0)&& (b.checkcorrectness(listitems) ==0))
                {
                    console.log("Found",b);
                    listmashineitems.addQuadrant(b);
                    b.reload(canvas)
                    return 1;
                }
            }
        }

        console.log("NO moves!");
        b.reload(canvas)


        //
        // // console.log("in other",allowed_u);
        // // var allowed_m = listmashineitems.addQuadrant(b);
        // // console.log("in my",allowed_m);
        // console.log("B",b)
        // // while (allowed_u === 0  || allowed_m == 0){
        // let candidad = listmashineitems.proposeNewPlace(b.n,b.m);
        // console.log("Candidat",candidad)
        // b.steprand(canvas,candidad);
        // console.log("B After step",b)
        // // allowed_u = listitems.addQuadrant(b,fix=0);
        // console.log("Quad:",b,"correctness:",b.checkcorrectness(listmashineitems));
        // // console.log(b.checkcorrectness(listmashineitems))
        // allowed_m = listmashineitems.addQuadrant(b);
        // console.log("results:",allowed_u,allowed_m);
        //
        // if (allowed_m ===1){
        //     console.log("Reloading! ")
        //     b.reload(canvas)
        // }
        // b.output();
    }

    function draw() {
         if (a){
            // console.log("a=",a)
             }
             else {
             a = new Quadrant(1, 1);
         }
        var canvas = document.getElementById("main");
        drawgrid(canvas)
        // canvas.addEventListener("mousedown", click1, false);
        // canvas.addEventListener("mousedown", function(){Element(canvas)}, false);
        window.addEventListener("keyup", function (event) {
            console.log(event)
            if(event.key == ' '){
                a.rotate(canvas)
                a.output();
            }
            if ( event.key =="ArrowRight"){
                console.log(a);
                a.moveright(canvas)
            }
            if ( event.key =="ArrowLeft"){
                console.log(a);
                a.moveleft(canvas)
            }
            if ( event.key =="ArrowUp"){
                console.log(a);
                a.moveup(canvas)
            }
            if ( event.key =="ArrowDown"){
                console.log(a);
                a.movedown(canvas)
            }
            if ( event.key =="f"){
                console.log(a);
                a.fix(canvas,listitems);
                mashinegame(canvas);
                // console.log(listitems)
            }
            if ( event.key =="m"){
                // console.log(a);
                // listitems.drawQlist(canvas)
                mashinegame(canvas)
            }
        }, false);


        // console.log('m here 1');
    }

    function drawgrid(canvas){
       let ctx = canvas.getContext("2d");
        var step = canvas.width/nlines;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for ( let  i=0;i<nlines;i++ ){
            ctx.moveTo(step*i,0);
          ctx.lineTo(step*i,canvas.height);
        }

        var step = canvas.height/nlines;
        for ( let  i=0; i< nlines ;i++ ){
            ctx.moveTo(0, step*i,0);
          ctx.lineTo(canvas.width,step*i);
        }
        ctx.stroke();
        listitems.drawQlist(canvas);
        listmashineitems.drawQlist(canvas);
    }

    function  drawpixel(x,y) {
        let canvas = document.getElementById("main");
        let ctx = canvas.getContext("2d");
            ctx.save();
            ctx.fillStyle="rgba(255,255,0,0.5)";
            let s = getCellsize();
            ctx.fillRect(x*s[0],y*s[1],s[0],s[1]);
            ctx.restore();

    }
     function  clearpixel(x,y) {
        let canvas = document.getElementById("main");
        let ctx = canvas.getContext("2d");
            ctx.save();
            ctx.fillStyle="rgba(255,255,255,1)";
            let s = getCellsize();
            ctx.fillRect(x*s[0],y*s[1],s[0],s[1]);
            ctx.restore();

    }
    function getCellsize(){
        var canvas = document.getElementById("main"); // todo  научиться передавать в  аргументе тоже
      // var el = event.srcElement;
      var q_w = parseFloat(canvas.width/nlines);
      var q_h = parseFloat(canvas.height/nlines);
      return [q_w,q_h]
    }




  </script>




</head>

<body onload="draw()">

  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->

  <p>Hello world! This is HTML5 Boilerplate.</p>
  <canvas  id="main" width="400" height="400" > </canvas>



  <!-- Add your site or application content here -->

  <script src="js/vendor/modernizr-{{MODERNIZR_VERSION}}.min.js"></script>
  <script src="https://code.jquery.com/jquery-{{JQUERY_VERSION}}.min.js" integrity="{{JQUERY_SRI_HASH}}" crossorigin="anonymous"></script>
  <script>window.jQuery || document.write('<script src="js/vendor/jquery-{{JQUERY_VERSION}}.min.js"><\/script>')</script>
  <script src="js/plugins.js"></script>
  <script src="js/main.js"></script>

  <!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-XXXXX-Y', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>
</body>

</html>
